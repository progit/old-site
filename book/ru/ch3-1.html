---
layout: translation
title: Pro Git 3.1 Ветвление в Git Что такое Ветвь
---
<h2 id='__'>Что такое Ветвь</h2>

<p>Чтобы на самом деле разобраться в том как Git работает с ветками, мы должны сделать шаг назад и рассмотреть, как Git хранит свои данные. Как вы наверное помните из Главы 1, Git не хранит данные как последовательность изменений или дельт, а как последовательность снимков состояния (snapshot).</p>

<p>Когда вы фиксируете изменения в Git, Git сохраняет фиксируемый объект, который содержит указатель на снимок содержимого индекса, метаданные автора и комментария и ноль или больше указателей на коммиты, которые были прямыми предками этого коммита: ноль предков для первого коммита, один — для обычного коммита и несколько — для коммита, полученного в результате слияния двух или более веток.</p>

<p>Для наглядности, давайте предположим, что у вас есть каталог, содержащий три файла, и вы их все индексируете и делаете коммит. При подготовке файлов для каждого из них вычисляется контрольная сумма (SHA-1 хэш мы упоминали в Главе 1), затем эта версия файла сохраняется в Git-репозиторий (Git обращается к ним как к двоичным данным), и эта контрольная сумма добавляется в индекс:</p>

<pre><code>$ git add README test.rb LICENSE
$ git commit -m &#39;initial commit of my project&#39;</code></pre>

<p>Когда вы создаёте коммит выполняя <code>git commit</code>, Git вычисляет контрольную сумму каждого подкаталога (в нашем случае, только корневого каталога) и сохраняет объекты для этого дерева в Git-репозиторий. Затем Git создаёт объект для коммита, который имеет метаданные и указатель на корень проектного дерева. Таким образом, Git может воссоздать текущее состояние, когда нужно.</p>

<p>Ваш Git-репозиторий теперь содержит пять объектов: по одному массиву двоичных данных для содержимого каждого из трёх файлов, одно дерево, которое перечисляет содержимое каталога и определяет соответствие имён файлов и массивов двоичных данных, и один коммит с указателем на корень этого дерева и все метаданные коммита. Схематично, данные в вашем Git-репозитории выглядят, как показано на Рисунке 3-1.</p>

<p><center><img src="/figures/ch3/18333fig0301-tn.png"></center><br/> Рисунок 3-1. Данные репозитория с единственным коммитом.</p>

<p>Если вы сделаете некоторые изменения и зафиксируете их, следующий коммит сохранит указатель на коммит, который шёл непосредственно перед ним. После еще двух коммитов ваша история может выглядеть, как показано на Рисунке 3-2.</p>

<p><center><img src="/figures/ch3/18333fig0302-tn.png"></center><br/> Рисунок 3-2. Данные объектов Git в случае нескольких коммитов.</p>

<p>Ветвь в Git — это просто легковесный подвижный указатель на один из этих коммитов. Имя ветки по умолчанию в Git — master. Когда вы вначале создаёте коммиты, вам даётся ветвь master, указывающая на последний сделанный коммит. При каждом новом коммите, указатель двигается вперёд автоматически.</p>

<p><center><img src="/figures/ch3/18333fig0303-tn.png"></center><br/> Рисунок 3-3. Ветка указывает на историю коммитов.</p>

<p>Что происходит, когда вы создаёте новую ветку? Итак, этим вы создаёте новый указатель, который вы можете перемещать. Скажем, вы создаёте новую ветку под названием testing. Это делается командой <code>git branch</code>:</p>

<pre><code>$ git branch testing</code></pre>

<p>Эта команда создает новый указатель на тот самый коммит, на котором вы сейчас находитесь (см. Рисунок 3-4).</p>

<p><center><img src="/figures/ch3/18333fig0304-tn.png"></center><br/> Рисунок 3-4. Несколько веток, указывающих на историю коммитов.</p>

<p>Откуда Git узнает, на какой ветке вы находитесь в данный момент? Он хранит специальный указатель, который называется HEAD (верхушка). Учтите, что это сильно отличается от концепции HEAD в других СУВ, таких как Subversion или CVS, к которым вы возможно привыкли. В Git это указатель на локальную ветку, на которой вы находитесь. В данном случае вы всё ещё на ветке master. Команда git branch только создала новую ветвь, она не переключила вас на неё (см. Рисунок 3-5).</p>

<p><center><img src="/figures/ch3/18333fig0305-tn.png"></center><br/> Рисунок 3-5. Файл HEAD указывает на текущую ветку.</p>

<p>Чтобы перейти на существующую ветку, вам надо выполнить команду <code>git checkout</code>. Давайте перейдем на новую ветку testing:</p>

<pre><code>$ git checkout testing</code></pre>

<p>Это действие перемещает HEAD так, чтобы тот указывал на ветку testing (см. Рисунок 3-6).</p>

<p><center><img src="/figures/ch3/18333fig0306-tn.png"></center><br/> Рисунок 3-6. HEAD указывает на другую ветку, когда вы их переключаете.</p>

<p>В чём важность этого действия? Давайте сделаем ещё один коммит:</p>

<pre><code>$ vim test.rb
$ git commit -a -m &#39;made a change&#39;</code></pre>

<p>На Рисунке 3-7 показан результат.</p>

<p><center><img src="/figures/ch3/18333fig0307-tn.png"></center><br/> Рисунок 3-7. Ветка, на которую указывает HEAD, движется вперёд с каждым коммитом.</p>

<p>Это интересно, потому что теперь ваша ветка testing передвинулась вперёд, но ваша ветвь master всё ещё указывает на коммит, на котором вы были, когда выполняли <code>git checkout</code>, чтобы переключить ветки. Давайте перейдём обратно на ветвь master:</p>

<pre><code>$ git checkout master</code></pre>

<p>На Рисунке 3-8 можно увидеть результат.</p>

<p><center><img src="/figures/ch3/18333fig0308-tn.png"></center><br/> Рисунок 3-8. HEAD перемещается на другую ветку при checkout&#8217;е.</p>

<p>Эта команда выполнила два действия. Она передвинула указатель HEAD назад на ветку master и вернула файлы в вашем рабочем каталоге назад, в соответствие со снимком состояния, на который указывает master. Это также означает, что изменения, которые вы делаете, начиная с этого момента, будут ответвляться от старой версии проекта. Это полностью откатывает изменения, которые вы временно делали на ветке testing. Таким образом, дальше вы можете двигаться в другом направлении.</p>

<p>Давайте снова сделаем немного изменений и зафиксируем их:</p>

<pre><code>$ vim test.rb
$ git commit -a -m &#39;made other changes&#39;</code></pre>

<p>Теперь история вашего проекта разветвилась (см. Рисунок 3-9). Вы создали новую ветку, перешли на неё, поработали на ней немного, переключились обратно на основную ветку и выполнили другую работу. Оба эти изменения изолированы на отдельных ветках: вы можете переключаться туда и обратно между ветвями и слить их, когда будете готовы. И вы сделали всё это простыми командами <code>branch</code> и <code>checkout</code>.</p>

<p><center><img src="/figures/ch3/18333fig0309-tn.png"></center><br/> Рисунок 3-9. История с разошедшимися ветками.</p>

<p>Из-за того, что ветка в Git на самом деле является простым файлом, который содержит 40 символов контрольной суммы SHA-1 коммита, на который он указывает, создание и удаление веток практически беззатратно. Создание новой ветки настолько же быстро и просто, как запись 41 байта в файл (40 символов + символ перехода на новую строку).</p>

<p>Это разительно отличается от того как в большинстве СУВ делается ветвление. Там это приводит к копированию всех файлов проекта в другой каталог. Это может занять несколько секунд или даже минут, в зависимости от размера проекта, тогда как в Git этот процесс всегда моментален. Также, из-за того что мы запоминаем предков для каждого коммита, поиск нужной базовой версии для слияния уже автоматически выполнен за нас, и в общем случае слияние делается легко. Эти особенности помогают поощрять разработчиков к частому созданию и использованию ветвей.</p>

<p>Давайте поймём, почему вам стоит так делать.</p>

<div id='nav'>
<a href='ch3-0.html'>prev</a> | <a href='ch3-2.html'>next</a>
</div>