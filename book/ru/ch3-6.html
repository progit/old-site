---
layout: translation
title: Pro Git 3.6 Ветвление в Git Перемещение
---
<h2 id='id193'>Перемещение</h2>

<p>В Git есть два способа включить изменения из одной ветки в другую: <code>merge</code> (слияние) и <code>rebase</code> (перемещение). В этом разделе вы узнаете, что такое перемещение, как его осуществлять, почему это удивительный инструмент и в каких случаях вам не следует его использовать.</p>

<h3 id='_'>Основы перемещения</h3>

<p>Если вы вернетесь назад к примеру из раздела Слияние (смотри Рисунок 3-27), вы увидите, что вы разделили вашу работу на два направления и выполняли коммиты на двух разных ветках.</p>

<p><center><img src="/figures/ch3/18333fig0327-tn.png"></center><br/> Рисунок 3-27. Впервые разделенная история коммитов.</p>

<p>Наиболее простое решение для объединения веток, как мы уже выяснили, команда <code>merge</code>. Эта команда выполняет трехходовое слияние между двумя последними снимками состояний из веток (C3 и C4) и последним общим предком этих двух веток (C2), создавая новый снимок состояния (и коммит), как показано на Рисунке 3-28.</p>

<p><center><img src="/figures/ch3/18333fig0328-tn.png"></center><br/> Рисунок 3-28. Слияние ветки для объединения разделившейся истории разработки.</p>

<p>Однако, есть и другой путь: вы можете взять изменения, представленные в C3, и применить их сверху C4. В Git это называется <em>перемещение</em> (rebasing). При помощи команды <code>rebase</code> вы можете взять все изменения, которые попали в коммиты на одной из веток, и повторить их на другой.</p>

<p>В этом примере вы выполните следующее:</p>

<pre><code>$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre>

<p>Это работает следующим образом: находится общий предок для двух веток (на которой вы находитесь сейчас и на которую вы выполняете перемещение); берётся разница, представленная в каждом из коммитов на текущей ветке, и сохраняется во временные файлы; текущая ветка устанавливается на такой же коммит, что и ветка, на которую вы выполняете перемещение; и, наконец, последовательно применяются все изменения. Рисунок 3-29 иллюстрирует этот процесс.</p>

<p><center><img src="/figures/ch3/18333fig0329-tn.png"></center><br/> Рисунок 3-29. Перемещение изменений, сделанных в C3, на C4.</p>

<p>На этом этапе можно переключиться на ветку master и выполнить слияние-перемотку (fast-forward merge) (смотри Рисунок 3-30).</p>

<p><center><img src="/figures/ch3/18333fig0330-tn.png"></center><br/> Рисунок 3-30. Перемотка ветки master.</p>

<p>Теперь снимок состояния, на который указывает C3, точно такой же, что тот, на который указывал C5 в примере со слиянием. Нет никакой разницы в конечном результате объединения, но перемещение выполняется для того, чтобы история была более аккуратной. Если вы посмотрите лог (log) перемещенной ветки, то увидите, что он выглядит как линейная история работы: выходит, что вся работа выполнялась последовательно, когда в действительности она выполнялась параллельно.</p>

<p>Часто вы будете делать это, чтобы удостовериться, что ваши коммиты правильно применяются для удаленных веток — возможно для проекта, владельцем которого вы не являетесь, но в который вы хотите внести свой вклад. В этом случае вы будете выполнять работу в ветке, а затем, когда будете готовы внести свои изменения в основной проект, выполните перемещение вашей работы на <code>origin/master</code>. Таким образом, владельцу проекта не придется делать никаких действий по объединению — просто перемотка (fast-forward) или чистое применение патчей.</p>

<p>Заметьте, что снимок состояния, на который указывает последний коммит, который у вас получился, является ли этот коммит последним перемещенным коммитом (для случая выполнения перемещения) или итоговым коммитом слияния (для случая выполнения слияния), есть один и тот же снимок — разной будет только история. Перемещение применяет изменения из одной линии разработки в другую в том порядке, в котором они были представлены, тогда как слияние объединяет вместе конечные точки двух веток.</p>

<h3 id='__'>Более интересные перемещения</h3>

<p>Вы также можете выполнять перемещение не только для перемещения ветки. Возьмём, например, историю разработки как на Рисунке 3-31. Вы создали тематическую ветку (<code>server</code>), чтобы добавить в проект некоторый функционал для серверной части, и сделали коммит. Затем вы выполнили ответвление, чтобы сделать изменения для клиентской части, и несколько раз выполнили коммиты. Наконец, вы вернулись на ветку server и сделали ещё несколько коммитов.</p>

<p><center><img src="/figures/ch3/18333fig0331-tn.png"></center><br/> Рисунок 3-31. История разработки с тематической веткой, ответвленной от другой тематической ветки.</p>

<p>Предположим, вы решили, что хотите внести ваши изменения для клиентской части в основную линию разработки для релиза, но при этом хотите оставить в стороне изменения для серверной части, пока они не будут полностью протестированы. Вы можете взять изменения из ветки client, которых нет на server (C8 и C9), и применить их на ветке master при помощи опции <code>--onto</code> команды <code>git rebase</code>:</p>

<pre><code>$ git rebase --onto master server client</code></pre>

<p>По сути, это указание “переключиться на ветку client, взять изменения от общего предка веток <code>client</code> и <code>server</code> и повторить их на <code>master</code>”. Это немного сложно; но результат, показанный на Рисунке 3-32, достаточно классный.</p>

<p><center><img src="/figures/ch3/18333fig0332-tn.png"></center><br/> Рисунок 3-32. Перемещение тематической ветки, ответвленной от другой тематической ветки.</p>

<p>Теперь вы можете выполнить перемотку (fast-forward) для вашей ветки master (смотри Рисунок 3-33):</p>

<pre><code>$ git checkout master
$ git merge client</code></pre>

<p><center><img src="/figures/ch3/18333fig0333-tn.png"></center><br/> Рисунок 3-33. Перемотка ветки master, чтобы включить изменения из ветки client.</p>

<p>Представим, что вы также решили включить ветку server в основную ветку. Вы можете выполнить перемещение ветки server на ветку master без предварительного переключения на эту ветку при помощи команды <code>git rebase [осн. ветка] [тем. ветка]</code> — которая устанавливает тематическую ветку (в данном случае <code>server</code>) как текущую и применяет её изменения на основной ветке (<code>master</code>):</p>

<pre><code>$ git rebase master server</code></pre>

<p>Эта команда применит изменения из вашей работы над веткой <code>server</code> на вершину ветки <code>master</code>, как показано на Рисунке 3-34.</p>

<p><center><img src="/figures/ch3/18333fig0334-tn.png"></center><br/> Рисунок 3-34. Перемещение вашей ветки server на вершину ветки master.</p>

<p>Затем вы можете выполнить перемотку (fast-forward) основной ветки (<code>master</code>):</p>

<pre><code>$ git checkout master
$ git merge server</code></pre>

<p>Вы можете удалить ветки <code>client</code> и <code>server</code>, так как вся работа из них включена в основную линию разработки и они вам больше не нужны. При этом полная история вашего рабочего процесса выглядит как на Рисунке 3-35:</p>

<pre><code>$ git branch -d client
$ git branch -d server</code></pre>

<p><center><img src="/figures/ch3/18333fig0335-tn.png"></center><br/> Рисунок 3-35. Финальная история коммитов.</p>

<h3 id='__'>Возможные риски перемещения</h3>

<p>Все бы хорошо, но кое-что омрачает всю прелесть использования перемещения. Это выражается одной строчкой:</p>

<p><strong>Не перемещайте коммиты, которые вы выложили в публичный репозиторий.</strong></p>

<p>Если вы будете следовать этому указанию, все будет хорошо. Если нет — люди возненавидят вас, вас будут презирать ваши друзья и семья.</p>

<p>Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаете новые, которые являются похожими на старые, но в чем-то другими. Если вы выкладываете ваши коммиты куда-нибудь, и другие забирают их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой <code>git rebase</code> и выкладываете их снова, ваши коллеги будут вынуждены заново выполнять слияние для своих наработок. Все запутается, когда вы в очередной раз попытаетесь включить их работу в свою.</p>

<p>Давайте рассмотрим пример того, как выполненное вами перемещение наработок, представленных для общего доступа, может вызвать проблемы. Представьте себе, что вы клонировали себе репозиторий с центрального сервера и поработали в нем. Ваша история коммитов выглядит как на Рисунке 3-36.</p>

<p><center><img src="/figures/ch3/18333fig0336-tn.png"></center><br/> Рисунок 3-36. Клонирование репозитория и выполнение в нём какой-то работы.</p>

<p>Теперь кто-то ещё выполняет работу, причём работа включает в себя и слияние, и отправляет свои изменения на центральный сервер. Вы извлекаете их и сливаете новую удалённую ветку со своей работой. Тогда ваша история выглядит как на Рисунке 3-37.</p>

<p><center><img src="/figures/ch3/18333fig0337-tn.png"></center><br/> Рисунок 3-37. Извлечение коммитов и слияние их со своей работой.</p>

<p>Далее, человек, выложивший изменения содержащие слияние, решает вернуться и вместо слияния (merge) переместить (rebase) свою работу; он выполняет <code>git push --force</code>, чтобы переписать историю на сервере. Затем вы извлекаете изменения с этого сервера, включая и новые коммиты.</p>

<p><center><img src="/figures/ch3/18333fig0338-tn.png"></center><br/> Рисунок 3-38. Кто-то выложил перемещённые коммиты, отменяя коммиты, на которых вы основывали свою работу.</p>

<p>На этом этапе вы вынуждены объединить эту работу со своей снова, даже если вы уже сделали это ранее. Перемещение изменяет у этих коммитов SHA-1 хеши, так что для Git они выглядят как новые коммиты, тогда как на самом деле вы уже располагаете наработками C4 в вашей истории (смотри Рисунок 3-39).</p>

<p><center><img src="/figures/ch3/18333fig0339-tn.png"></center><br/> Рисунок 3-39. Вы снова выполняете слияние для той же самой работы в новый коммит слияния.</p>

<p>Вы вынуждены объединить эту работу со своей на каком-либо этапе, чтобы иметь возможность продолжать работать с другими разработчиками в будущем. После того, как вы сделаете это, ваша история коммитов будет содержать оба коммита — C4 и C4&#8217;, которые имеют разные SHA-1 хеши , но представляют собой одинаковые изменения и имеют одинаковые сообщения. Если вы выполните команду <code>git log</code> когда ваша история выглядит таким образом, вы увидите два коммита, которые имеют одинакового автора и одни и те же сообщения. Это сбивает с толку. Более того, если вы отправите такую историю обратно на сервер, вы добавите все эти перемещенные коммиты в репозиторий центрального сервера, что может ещё больше запутать людей.</p>

<p>Если вы рассматриваете перемещение как возможность наведения порядка и работы с коммитами до того, как выложили их, и если вы перемещаете только коммиты, которые никогда не находились в публичном доступе — всё нормально. Если вы перемещаете коммиты, которые уже были представлены для общего доступа, и люди, возможно, основывали свою работу на этих коммитах, тогда вы можете получить наказание за разные неприятные проблемы.</p>

<div id='nav'>
<a href='ch3-5.html'>prev</a> | <a href='ch3-7.html'>next</a>
</div>