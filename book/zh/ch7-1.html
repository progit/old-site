---
layout: translation
title: Pro Git 7.1 自定义Git 配置Git
---
<h2 id='git'>配置Git</h2>

<p>正如你在第一章见到的那样，你能用<code>git config</code>配置Git，要做的第一件事就是设置名字和邮箱地址：</p>

<pre><code>$ git config --global user.name &quot;John Doe&quot;
$ git config --global user.email johndoe@example.com</code></pre>

<p>从现在开始，你会了解到一些更为有趣的设置选项，按照以上方式来自定义Git。</p>

<p>我会在这先过一遍第一章中提到的Git配置细节。Git使用一系列的配置文件来存储你定义的偏好，它首先会查找<code>/etc/gitconfig</code>文件，该文件含有 对系统上所有用户及他们所拥有的仓库都生效的配置值（译注：gitconfig是全局配置文件）， 如果传递<code>--system</code>选项给<code>git config</code>命令，Git会读写这个文件。</p>

<p>接下来Git会查找每个用户的<code>~/.gitconfig</code>文件，你能传递<code>--global</code>选项让Git读写该文件。</p>

<p>最后Git会查找由用户定义的各个库中Git目录下的配置文件（<code>.git/config</code>），该文件中的值只对属主库有效。 以上阐述的三层配置从一般到特殊层层推进，如果定义的值有冲突，以后面层中定义的为准，例如：在<code>.git/config</code>和<code>/etc/gitconfig</code>的较量中， <code>.git/config</code>取得了胜利。虽然你也可以直接手动编辑这些配置文件，但是运行<code>git config</code>命令将会来得简单些。</p>

<h3 id='id272'>客户端基本配置</h3>

<p>Git能够识别的配置项被分为了两大类：客户端和服务器端，其中大部分基于你个人工作偏好，属于客户端配置。尽管有数不尽的选项，但我只阐述 其中经常使用或者会对你的工作流产生巨大影响的选项，如果你想观察你当前的Git能识别的选项列表，请运行</p>

<pre><code>$ git config --help</code></pre>

<p><code>git config</code>的手册页（译注：以man命令的显示方式）非常细致地罗列了所有可用的配置项。</p>

<h4 id='coreeditor'>core.editor</h4>

<p>Git默认会调用你的环境变量editor定义的值作为文本编辑器，如果没有定义的话，会调用Vi来创建和编辑提交以及标签信息， 你可以使用<code>core.editor</code>改变默认编辑器：</p>

<pre><code>$ git config --global core.editor emacs</code></pre>

<p>现在无论你的环境变量editor被定义成什么，Git都会调用Emacs编辑信息。</p>

<h4 id='committemplate'>commit.template</h4>

<p>如果把此项指定为你系统上的一个文件，当你提交的时候，Git会默认使用该文件定义的内容。 例如：你创建了一个模板文件<code>$HOME/.gitmessage.txt</code>，它看起来像这样：</p>

<pre><code>subject line

what happened

[ticket: X]</code></pre>

<p>设置<code>commit.template</code>，当运行<code>git commit</code>时，Git会在你的编辑器中显示以上的内容， 设置<code>commit.template</code>如下：</p>

<pre><code>$ git config --global commit.template $HOME/.gitmessage.txt
$ git commit</code></pre>

<p>然后当你提交时，在编辑器中显示的提交信息如下：</p>

<pre><code>subject line

what happened

[ticket: X]
# Please enter the commit message for your changes. Lines starting
# with &#39;#&#39; will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
#
# modified:   lib/test.rb
#
~
~
&quot;.git/COMMIT_EDITMSG&quot; 14L, 297C</code></pre>

<p>如果你有特定的策略要运用在提交信息上，在系统上创建一个模板文件，设置Git默认使用它，这样当提交时，你的策略每次都会被运用。</p>

<h4 id='corepager'>core.pager</h4>

<p>core.pager指定Git运行诸如<code>log</code>、<code>diff</code>等所使用的分页器，你能设置成用<code>more</code>或者任何你喜欢的分页器（默认用的是<code>less</code>）， 当然你也可以什么都不用，设置空字符串：</p>

<pre><code>$ git config --global core.pager &#39;&#39;</code></pre>

<p>这样不管命令的输出量多少，都会在一页显示所有内容。</p>

<h4 id='usersigningkey'>user.signingkey</h4>

<p>如果你要创建经签署的含附注的标签（正如第二章所述），那么把你的GPG签署密钥设置为配置项会更好，设置密钥ID如下：</p>

<pre><code>$ git config --global user.signingkey &lt;gpg-key-id&gt;</code></pre>

<p>现在你能够签署标签，从而不必每次运行<code>git tag</code>命令时定义密钥：</p>

<pre><code>$ git tag -s &lt;tag-name&gt;</code></pre>

<h4 id='coreexcludesfile'>core.excludesfile</h4>

<p>正如第二章所述，你能在项目库的<code>.gitignore</code>文件里头用模式来定义那些无需纳入Git管理的文件，这样它们不会出现在未跟踪列表， 也不会在你运行<code>git add</code>后被暂存。然而，如果你想用项目库之外的文件来定义那些需被忽略的文件的话，用<code>core.excludesfile</code> 通知Git该文件所处的位置，文件内容和<code>.gitignore</code>类似。</p>

<h4 id='helpautocorrect'>help.autocorrect</h4>

<p>该配置项只在Git 1.6.1及以上版本有效，假如你在Git 1.6中错打了一条命令，会显示：</p>

<pre><code>$ git com
git: &#39;com&#39; is not a git-command. See &#39;git --help&#39;.

Did you mean this?
     commit</code></pre>

<p>如果你把<code>help.autocorrect</code>设置成1（译注：启动自动修正），那么在只有一个命令被模糊匹配到的情况下，Git会自动运行该命令。</p>

<h3 id='git'>Git中的着色</h3>

<p>Git能够为输出到你终端的内容着色，以便你可以凭直观进行快速、简单地分析，有许多选项能供你使用以符合你的偏好。</p>

<h4 id='colorui'>color.ui</h4>

<p>Git会按照你需要自动为大部分的输出加上颜色，你能明确地规定哪些需要着色以及怎样着色，设置<code>color.ui</code>为true来打开所有的默认终端着色。</p>

<pre><code>$ git config --global color.ui true</code></pre>

<p>设置好以后，当输出到终端时，Git会为之加上颜色。其他的参数还有false和always，false意味着不为输出着色，而always则表明在任何情况下 都要着色，即使Git命令被重定向到文件或管道。Git 1.5.5版本引进了此项配置，如果你拥有的版本更老，你必须对颜色有关选项各自进行详细地设置。</p>

<p>你会很少用到<code>color.ui = always</code>，在大多数情况下，如果你想在被重定向的输出中插入颜色码，你能传递<code>--color</code>标志给Git命令来迫使 它这么做，<code>color.ui = true</code>应该是你的首选。</p>

<h4 id='id273'><code>color.*</code></h4>

<p>想要具体到哪些命令输出需要被着色以及怎样着色或者Git的版本很老，你就要用到和具体命令有关的颜色配置选项， 它们都能被置为<code>true</code>、<code>false</code>或<code>always</code>：</p>

<pre><code>color.branch
color.diff
color.interactive
color.status</code></pre>

<p>除此之外，以上每个选项都有子选项，可以被用来覆盖其父设置，以达到为输出的各个部分着色的目的。 例如，让diff输出的改变信息以粗体、蓝色前景和黑色背景的形式显示：</p>

<pre><code>$ git config --global color.diff.meta “blue black bold”</code></pre>

<p>你能设置的颜色值如：normal、black、red、green、yellow、blue、magenta、cyan、white， 正如以上例子设置的粗体属性，想要设置字体属性的话，可以选择如：bold、dim、ul、blink、reverse。</p>

<p>如果你想配置子选项的话，可以参考<code>git config</code>帮助页。</p>

<h3 id='id274'>外部的合并与比较工具</h3>

<p>虽然Git自己实现了diff,而且到目前为止你一直在使用它，但你能够用一个外部的工具替代它，除此以外，你还能用一个图形化的工具来合并和解决冲突 从而不必自己手动解决。有一个不错且免费的工具可以被用来做比较和合并工作，它就是P4Merge（译注：Perforce图形化合并工具），我会展示它的安装过程。</p>

<p>P4Merge可以在所有主流平台上运行，现在开始大胆尝试吧。对于向你展示的例子，在Mac和Linux系统上，我会使用路径名， 在Windows上，<code>/usr/local/bin</code>应该被改为你环境中的可执行路径。</p>

<p>下载P4Merge：</p>

<pre><code>http://www.perforce.com/perforce/downloads/component.html</code></pre>

<p>首先把你要运行的命令放入外部包装脚本中，我会使用Mac系统上的路径来指定该脚本的位置，在其他系统上， 它应该被放置在二进制文件<code>p4merge</code>所在的目录中。创建一个merge包装脚本，名字叫作<code>extMerge</code>，让它带参数调用<code>p4merge</code>二进制文件：</p>

<pre><code>$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*</code></pre>

<p>diff包装脚本首先确定传递过来7个参数，随后把其中2个传递给merge包装脚本，默认情况下，Git传递以下参数给diff：</p>

<pre><code>path old-file old-hex old-mode new-file new-hex new-mode</code></pre>

<p>由于你仅仅需要<code>old-file</code>和<code>new-file</code>参数，用diff包装脚本来传递它们吧。</p>

<pre><code>$ cat /usr/local/bin/extDiff 
#!/bin/sh
[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge &quot;$2&quot; &quot;$5&quot;</code></pre>

<p>确认这两个脚本是可执行的：</p>

<pre><code>$ sudo chmod +x /usr/local/bin/extMerge 
$ sudo chmod +x /usr/local/bin/extDiff</code></pre>

<p>现在来配置使用你自定义的比较和合并工具吧。这需要许多自定义设置：<code>merge.tool</code>通知Git使用哪个合并工具； <code>mergetool.*.cmd</code>规定命令运行的方式；<code>mergetool.trustExitCode</code>会通知Git程序的退出是否指示合并操作成功； <code>diff.external</code>通知Git用什么命令做比较。因此，你能运行以下4条配置命令：</p>

<pre><code>$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
    &#39;extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;&#39;
$ git config --global mergetool.trustExitCode false
$ git config --global diff.external extDiff</code></pre>

<p>或者直接编辑<code>~/.gitconfig</code>文件如下：</p>

<pre><code>[merge]
  tool = extMerge
[mergetool &quot;extMerge&quot;]
  cmd = extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;
  trustExitCode = false
[diff]
  external = extDiff</code></pre>

<p>设置完毕后，运行diff命令：</p>

<pre><code>$ git diff 32d1776b1^ 32d1776b1</code></pre>

<p>命令行居然没有发现diff命令的输出，其实，Git调用了刚刚设置的P4Merge，它看起来像图7-1这样：</p>

<p><center><img src="/figures/ch7/18333fig0701-tn.png"></center><br/> Figure 7-1. P4Merge.</p>

<p>当你设法合并两个分支，结果却有冲突时，运行<code>git mergetool</code>，Git会调用P4Merge让你通过图形界面来解决冲突。</p>

<p>设置包装脚本的好处是你能简单地改变diff和merge工具，例如把<code>extDiff</code>和<code>extMerge</code>改成KDiff3，要做的仅仅是编辑<code>extMerge</code>脚本文件：</p>

<pre><code>$ cat /usr/local/bin/extMerge
#!/bin/sh	
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</code></pre>

<p>现在Git会使用KDiff3来做比较、合并和解决冲突。</p>

<p>Git预先设置了许多其他的合并和解决冲突的工具，而你不必设置cmd。可以把合并工具设置为： kdiff3、opendiff、tkdiff、meld、xxdiff、emerge、vimdiff、gvimdiff。如果你不想用到KDiff3的所有功能，只是想用它来合并， 那么kdiff3正符合你的要求，运行：</p>

<pre><code>$ git config --global merge.tool kdiff3</code></pre>

<p>如果运行了以上命令，没有设置<code>extMerge</code>和<code>extDiff</code>文件，Git会用KDiff3做合并，让通常内设的比较工具来做比较。</p>

<h3 id='formatting_and_whitespace'>Formatting and Whitespace</h3>

<p>Formatting and whitespace issues are some of the more frustrating and subtle problems that many developers encounter when collaborating, especially cross-platform. It’s very easy for patches or other collaborated work to introduce subtle whitespace changes because editors silently introduce them or Windows programmers add carriage returns at the end of lines they touch in cross-platform projects. Git has a few configuration options to help with these issues.</p>

<h4 id='coreautocrlf'>core.autocrlf</h4>

<p>If you’re programming on Windows or using another system but working with people who are programming on Windows, you’ll probably run into line-ending issues at some point. This is because Windows uses both a carriage-return character and a linefeed character for newlines in its files, whereas Mac and Linux systems use only the linefeed character. This is a subtle but incredibly annoying fact of cross-platform work.</p>

<p>Git can handle this by auto-converting CRLF line endings into LF when you commit, and vice versa when it checks out code onto your filesystem. You can turn on this functionality with the <code>core.autocrlf</code> setting. If you’re on a Windows machine, set it to <code>true</code> — this converts LF endings into CRLF when you check out code:</p>

<pre><code>$ git config --global core.autocrlf true</code></pre>

<p>If you’re on a Linux or Mac system that uses LF line endings, then you don’t want Git to automatically convert them when you check out files; however, if a file with CRLF endings accidentally gets introduced, then you may want Git to fix it. You can tell Git to convert CRLF to LF on commit but not the other way around by setting <code>core.autocrlf</code> to input:</p>

<pre><code>$ git config --global core.autocrlf input</code></pre>

<p>This setup should leave you with CRLF endings in Windows checkouts but LF endings on Mac and Linux systems and in the repository.</p>

<p>If you’re a Windows programmer doing a Windows-only project, then you can turn off this functionality, recording the carriage returns in the repository by setting the config value to <code>false</code>:</p>

<pre><code>$ git config --global core.autocrlf false</code></pre>

<h4 id='corewhitespace'>core.whitespace</h4>

<p>Git comes preset to detect and fix some whitespace issues. It can look for four primary whitespace issues — two are enabled by default and can be turned off, and two aren’t enabled by default but can be activated.</p>

<p>The two that are turned on by default are <code>trailing-space</code>, which looks for spaces at the end of a line, and <code>space-before-tab</code>, which looks for spaces before tabs at the beginning of a line.</p>

<p>The two that are disabled by default but can be turned on are <code>indent-with-non-tab</code>, which looks for lines that begin with eight or more spaces instead of tabs, and <code>cr-at-eol</code>, which tells Git that carriage returns at the end of lines are OK.</p>

<p>You can tell Git which of these you want enabled by setting <code>core.whitespace</code> to the values you want on or off, separated by commas. You can disable settings by either leaving them out of the setting string or prepending a <code>-</code> in front of the value. For example, if you want all but <code>cr-at-eol</code> to be set, you can do this:</p>

<pre><code>$ git config --global core.whitespace \
    trailing-space,space-before-tab,indent-with-non-tab</code></pre>

<p>Git will detect these issues when you run a <code>git diff</code> command and try to color them so you can possibly fix them before you commit. It will also use these values to help you when you apply patches with <code>git apply</code>. When you’re applying patches, you can ask Git to warn you if it’s applying patches with the specified whitespace issues:</p>

<pre><code>$ git apply --whitespace=warn &lt;patch&gt;</code></pre>

<p>Or you can have Git try to automatically fix the issue before applying the patch:</p>

<pre><code>$ git apply --whitespace=fix &lt;patch&gt;</code></pre>

<p>These options apply to the git rebase option as well. If you’ve committed whitespace issues but haven’t yet pushed upstream, you can run a <code>rebase</code> with the <code>--whitespace=fix</code> option to have Git automatically fix whitespace issues as it’s rewriting the patches.</p>

<h3 id='server_configuration'>Server Configuration</h3>

<p>Not nearly as many configuration options are available for the server side of Git, but there are a few interesting ones you may want to take note of.</p>

<h4 id='receivefsckobjects'>receive.fsckObjects</h4>

<p>By default, Git doesn’t check for consistency all the objects it receives during a push. Although Git can check to make sure each object still matches its SHA-1 checksum and points to valid objects, it doesn’t do that by default on every push. This is a relatively expensive operation and may add a lot of time to each push, depending on the size of the repository or the push. If you want Git to check object consistency on every push, you can force it to do so by setting <code>receive.fsckObjects</code> to true:</p>

<pre><code>$ git config --system receive.fsckObjects true</code></pre>

<p>Now, Git will check the integrity of your repository before each push is accepted to make sure faulty clients aren’t introducing corrupt data.</p>

<h4 id='receivedenynonfastforwards'>receive.denyNonFastForwards</h4>

<p>If you rebase commits that you’ve already pushed and then try to push again, or otherwise try to push a commit to a remote branch that doesn’t contain the commit that the remote branch currently points to, you’ll be denied. This is generally good policy; but in the case of the rebase, you may determine that you know what you’re doing and can force-update the remote branch with a <code>-f</code> flag to your push command.</p>

<p>To disable the ability to force-update remote branches to non-fast-forward references, set <code>receive.denyNonFastForwards</code>:</p>

<pre><code>$ git config --system receive.denyNonFastForwards true</code></pre>

<p>The other way you can do this is via server-side receive hooks, which I’ll cover in a bit. That approach lets you do more complex things like deny non-fast-forwards to a certain subset of users.</p>

<h4 id='receivedenydeletes'>receive.denyDeletes</h4>

<p>One of the workarounds to the <code>denyNonFastForwards</code> policy is for the user to delete the branch and then push it back up with the new reference. In newer versions of Git (beginning with version 1.6.1), you can set <code>receive.denyDeletes</code> to true:</p>

<pre><code>$ git config --system receive.denyDeletes true</code></pre>

<p>This denies branch and tag deletion over a push across the board — no user can do it. To remove remote branches, you must remove the ref files from the server manually. There are also more interesting ways to do this on a per-user basis via ACLs, as you’ll learn at the end of this chapter.</p>

<div id='nav'>
<a href='ch7-0.html'>prev</a> | <a href='ch7-2.html'>next</a>
</div>